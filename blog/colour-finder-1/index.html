<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,minimum-scale=1" name=viewport><meta content="Finding the dominant colours in an image using javascript in the browser 100% client side" name=description><meta content=summary name=twitter:card><meta content=@ZyzleDotDev name=twitter:site><meta content=@ZyzleDotDev name=twitter:creator><meta content=https://zyzle.dev/blog/colour-finder-1/ property=og:url><meta content="Finding Colours - Part 1: This should be easy...right? | Blog | Zyzle.dev" property=og:title><meta content="Finding the dominant colours in an image using javascript in the browser 100% client side" property=og:description><meta content=https://zyzle.dev/blog/colour-finder-1/scanned-image.png property=og:image><meta content=article property=og:type><title>Finding Colours - Part 1: This should be easy...right? | Blog | Zyzle.dev</title><link href=https://zyzle.dev/atom.xml rel=alternate title=RSS type=application/atom+xml><style>@import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&family=Nunito:ital,wght@0,400;0,700;1,400;1,700&family=Pacifico&display=swap');</style><link href=https://zyzle.dev/styles.css rel=stylesheet><link href=/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/site.webmanifest rel=manifest><script src="https://www.googletagmanager.com/gtag/js?id=G-Q90233GSB3" async></script><script>function startAnalytics() {
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
    
                gtag('config', 'G-Q90233GSB3');
            }</script><script type=application/ld+json>
{
	"@context": "https://schema.org",
	"@type": "BlogPosting",
	"Headline": "Finding Colours - Part 1: This should be easy...right?",
	"datePublished": "2022-07-04",
	"author": [{
		"@type": "Person",
		"name": "Colin McCulloch",
		"url": "https://zyzle.dev/about"
	}],
    "wordcount": "2083",
    "keywords": "web-dev,fun,problems,",
    "license": "https://creativecommons.org/licenses/by-sa/4.0/"
}
</script><body><header class=page-header><div class=hwrapper><h1><a class=header-link href=https://zyzle.dev/>Zyzle.dev</a></h1><span class=header-buttons> <a title="Support me on ko-fi" href=https://ko-fi.com/zyzle><img alt="support me on Ko-fi" height=40px src=/ko-fi.svg width=40px></a> <a title="Site tags" href=/tags/><img alt="site tag list" height=40px src=/tag.svg width=40px></a> <a href=https://zyzle.dev/search/ title=Search><img alt="search zyzle.dev" height=40px src=/search.svg width=40px></a> </span></div><div id=progress-bar></div></header><div class=wrapper><main class=content id=docmain><nav><a href=https://zyzle.dev/blog/>Â« back to blogs</a></nav><article class=post><header class=post-header><h1>Finding Colours - Part 1: This should be easy...right?</h1><div class=post-info><time datetime=2022-07-04>2022-07-04</time><div class=tags><a href=https://zyzle.dev/tags/web-dev/>web-dev</a><a href=https://zyzle.dev/tags/fun/>fun</a><a href=https://zyzle.dev/tags/problems/>problems</a></div></div></header><p>During the interview for my current job, I was given a small pair-programming coding challenge to do. Like all good coding challenges it was probably beyond what could reasonably have been finished in an hour but it was fun and I got the job so my attempt couldn't have been too bad. Not finishing the challenge did annoy me though so here's my attempt at a more polished version of the challenge</p><span id=continue-reading></span><blockquote><p><strong>Update:</strong> Yes I know I'm mixing "colour" and "color" in this post, too much code writing over the years has warped my brain with American spellings :P I'll try and keep it to "colour" in copy and "color" in code from now on.</blockquote><blockquote><p><strong>Update 2:</strong> Somehow it escaped my notice that OffscreenCanvas in the way I'm using it here isn't compatible with either Firefox or Safari browsers! The correction can be found <a href=https://gist.github.com/Zyzle/1cf16675d7224ef90b0ef1639c7783a9>in this Gist</a>, serves me right for not checking the compatibility table at the bottom of each MDN page :D</blockquote><p>Anyone waiting for part 4 of the "Let's write a blog" series, worry not, it will come eventually I just got distracted playing with this :P<h2 id=the-challenge>The Challenge</h2><p>The challenge itself was worded something along the lines of "Load an image and find the top n colours used in it" (side note there are problems with this but we'll get to that in part 2). I'm going to extend this slightly with some requirements of my own because there are a few things I don't know how to do but want to learn.<p>I'm going to build a site with a dropzone I can drag an image into, at which point the process loop will take over, bring me back the dominant colours (have you spotted the problem yet?) from the image and display them to the user along with the dropped image.<h2 id=challenge-1-the-dropzone>Challenge 1: The dropzone</h2><p>This part is pretty easy, we just need to hook into a drop event and retrieve the file dropped.<blockquote><p><strong>Side note:</strong> For the code examples I'm going to be showing stripped down versions of the HTML without most of the structural elements or styling information. If you're interesting in seeing this you can have a look at the github repository for this project <a href=https://github.com/Zyzle/image-colours/tree/v1.0.0>Image-Colours</a></blockquote><pre class=language-html data-lang=html style=background-color:#282c34;color:#abb2bf;><code class=language-html data-lang=html><span><</span><span style=color:#e06c75;>img </span><span style=color:#98c379;>id</span><span>=</span><span style=color:#e5c07b;>"image-display" </span><span style=color:#98c379;>src</span><span>=</span><span style=color:#e5c07b;>"" </span><span>/>
</span><span><</span><span style=color:#e06c75;>div </span><span style=color:#98c379;>id</span><span>=</span><span style=color:#e5c07b;>"swatches"</span><span>>&LT/</span><span style=color:#e06c75;>div</span><span>>
</span><span><</span><span style=color:#e06c75;>div
</span><span>	</span><span style=color:#98c379;>id</span><span>=</span><span style=color:#e5c07b;>"drop-zone"
</span><span>	</span><span style=color:#98c379;>ondrop</span><span>=</span><span style=color:#e5c07b;>"</span><span>dropHandler(event);</span><span style=color:#e5c07b;>"</span><span>>
</span><span>	<</span><span style=color:#e06c75;>h2</span><span>>Drop Here&LT/</span><span style=color:#e06c75;>h2</span><span>>
</span><span>	<</span><span style=color:#e06c75;>p</span><span>>Drop an image into the box to analyze&LT/</span><span style=color:#e06c75;>p</span><span>>
</span><span>&LT/</span><span style=color:#e06c75;>div</span><span>>
</span></code></pre><p>This is all pretty simple, we have an <code>img</code> element with no pre-defined <code>src</code> attribute where our image will be shown to the user, an empty <code>div</code> that we'll add a list of our colours and a final <code>div</code> that'll act as our drop zone. I'll pretty it up with some styling and it'll look like the image below<figure><img alt="our dropzone styled and on the page" src=https://zyzle.dev/processed_images/79a0311c0d0e4a8f00.webp><figcaption>the styled dropzone</figcaption></figure><p>Let's have a look at the javascript, again I'm not going to do anything fancy here just bung a <code>script</code> tag at the bottom of the screen with the following code that'll display the image we've dropped into our empty <code>img</code> tag:<pre class=language-html data-lang=html style=background-color:#282c34;color:#abb2bf;><code class=language-html data-lang=html><span><</span><span style=color:#e06c75;>script </span><span style=color:#98c379;>type</span><span>=</span><span style=color:#e5c07b;>"text/javascript"</span><span>>
</span><span>	</span><span style=color:#56b6c2;>function </span><span style=color:#98c379;>dropHandler</span><span>(</span><span style=font-style:italic;color:#d19a66;>e</span><span>) {
</span><span>		</span><span style=color:#676f7d;>// 1
</span><span>		e.preventDefault();
</span><span>
</span><span>		</span><span style=color:#676f7d;>// 2
</span><span>		</span><span style=color:#e06c75;>if </span><span>(e.dataTransfer.items) {
</span><span>			</span><span style=color:#e06c75;>if </span><span>(e.dataTransfer.items[</span><span style=color:#c678dd;>0</span><span>].kind </span><span style=color:#e06c75;>=== </span><span style=color:#e5c07b;>'file'</span><span>) {
</span><span>				</span><span style=color:#676f7d;>// 3
</span><span>				</span><span style=color:#56b6c2;>const </span><span>file </span><span style=color:#e06c75;>= </span><span>e.dataTransfer.items[</span><span style=color:#c678dd;>0</span><span>].getAsFile();
</span><span>				</span><span style=color:#56b6c2;>const </span><span>output </span><span style=color:#e06c75;>= </span><span style=color:#56b6c2;>document</span><span>.getElementById(</span><span style=color:#e5c07b;>'image-display'</span><span>);
</span><span>				</span><span style=color:#676f7d;>// 4
</span><span>				output.src </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>URL</span><span>.createObjectURL(file);
</span><span>			}
</span><span>		}
</span><span>	}
</span><span>&LT/</span><span style=color:#e06c75;>script</span><span>>
</span></code></pre><p>Not much to see here, when a file is dropped onto our dropzone on the page we get this handler function called. I'll go through what we're doing here.<ol><li><code>e.preventDefault()</code> Most browsers, when an image is dropped into them will display that image, we kill this event here to stop it from propagating up and triggering this behaviour.<li>The drag event gives us a <a href=https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer>DataTransfer</a> object which contains a <code>DataTransferList</code> object, of the items being dragged in. We check if the first one of these is a file before continuing, I could also check the <code>type</code> property here to make sure it's actually an image but I'm lazy and don't really care if people try and drop something other than images.<li><code>getAsFile()</code> method unsurprisingly gives us a <code>File</code> object.<li>Which, finally we can create a URL for, and pass this to our <code>img</code> element displaying the image to the user</ol><h2 id=accessing-the-image-bitmap>Accessing the image bitmap</h2><p>So here's the plan. We have our image loaded now, we should iterate over it one pixel at a time, get that pixel's colour and take note, then add a +1 to a count for this particular colour every time another pixel with that colour is found.<p>The file object doesn't give me a way of accessing the image pixels directly, but I can create a bitmap from this file and render it to a canvas which I can then pull the raw image data from;<pre class=language-js data-lang=js style=background-color:#282c34;color:#abb2bf;><code class=language-js data-lang=js><span style=color:#98c379;>createImageBitmap</span><span>(file)
</span><span>	.</span><span style=color:#98c379;>then</span><span>(</span><span style=font-style:italic;color:#d19a66;>ibm </span><span style=color:#56b6c2;>=> </span><span>{
</span><span>		</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>canvas  </span><span style=color:#e06c75;>= new </span><span style=color:#61afef;>OffscreenCanvas</span><span>(</span><span style=color:#61afef;>ibm</span><span>.</span><span style=color:#56b6c2;>width</span><span>, </span><span style=color:#61afef;>ibm</span><span>.</span><span style=color:#56b6c2;>height</span><span>);
</span><span>		</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>ctx </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>canvas</span><span>.</span><span style=color:#98c379;>getContext</span><span>(</span><span style=color:#e5c07b;>'2d'</span><span>);
</span><span>	</span><span style=color:#61afef;>ctx</span><span>.</span><span style=color:#98c379;>drawImage</span><span>(ibm, </span><span style=color:#c678dd;>0</span><span>, </span><span style=color:#c678dd;>0</span><span>);
</span><span>
</span><span>	</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>imageData </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>ctx</span><span>.</span><span style=color:#98c379;>getImageData</span><span>(</span><span style=color:#c678dd;>0</span><span>, </span><span style=color:#c678dd;>0</span><span>, </span><span style=color:#61afef;>ibm</span><span>.</span><span style=color:#56b6c2;>width</span><span>, </span><span style=color:#61afef;>ibm</span><span>.</span><span style=color:#56b6c2;>height</span><span>).</span><span style=color:#56b6c2;>data</span><span>;
</span><span>
</span><span>	</span><span style=color:#676f7d;>// remaining code goes here
</span><span>});
</span></code></pre><p>This process returns a Promise so we do all the fun stuff in the resolution. I don't want to display the canvas on the page so using <code>OffscreenCanvas</code> is a good solution as it exists only in memory and doesn't require a target HTML element. Handily having the ImageBitmap object gives us the needed width and height properties so we know what size to make the canvas.<blockquote><p>The <a href=https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas><code>OffscreenCanvas</code></a> won't in itself provide any major performance benefits over it's regular counterpart, however it does give one major benefit, that the code can be moved into a web worker, this will allow expensive operations to be run in the background and not block the main thread. We wont be using this just yet but it's a nice feature</blockquote><p>We're working in a 2d context here rather than a 3d one so the first step is to retrieve that, and then we render our image into it, we use the whole image here so no need to specify the last 2 arguments of <code>drawImage</code>. In the final step here, we retrieve the image data back from the canvas starting at coordinates (0, 0) end ending at the width and height of the image so we get every pixel. The returned <a href=https://developer.mozilla.org/en-US/docs/Web/API/ImageData><code>ImageData</code></a> object contains an Unsigned 8 clamped array that contains the channel data for every pixel in the image in RGBA format, that is every 4 integers represents the channel information for one pixel in the image (Red, Green, Blue, Alpha) limited to the maximum value for an unsigned 8 int (255).<p>For example, imagine an image where every pixel alternates between pure white and pure black, the <code>ImageData</code> array for the first 4 pixels would look like this:<pre style=background-color:#282c34;color:#abb2bf;><code><span>     pixel 1         pixel 2         pixel 3         pixel 4
</span><span>|---------------|---------------|---------------|---------------|
</span><span>|255|255|255|255| 0 | 0 | 0 |255|255|255|255|255| 0 | 0 | 0 |255|
</span><span>|---------------|---------------|---------------|---------------|
</span><span>    #FFFFFFFF       #000000FF       #FFFFFFFF       #000000FF
</span></code></pre><p>The middle row above shows the 16 entries of the array, above them, are the individual pixel delimiters and below the HEX representation of the colours.<p>What We'll do now is consolidate these pixels into an array taking just the colour:<pre class=language-js data-lang=js style=background-color:#282c34;color:#abb2bf;><code class=language-js data-lang=js><span style=color:#56b6c2;>const </span><span style=color:#61afef;>pixelColors </span><span style=color:#e06c75;>= </span><span>[];
</span><span>
</span><span style=color:#e06c75;>for </span><span>(i </span><span style=color:#e06c75;>= </span><span style=color:#c678dd;>0</span><span>; i </span><span style=color:#e06c75;>< </span><span style=color:#61afef;>imageData</span><span>.</span><span style=color:#56b6c2;>length</span><span>; i </span><span style=color:#e06c75;>+= </span><span style=color:#c678dd;>4</span><span>) {
</span><span>	</span><span style=color:#61afef;>pixelColors</span><span>.</span><span style=color:#98c379;>push</span><span>([
</span><span>    </span><span style=color:#676f7d;>// 1
</span><span>		</span><span style=color:#e5c07b;>'#'</span><span>,
</span><span>    </span><span style=color:#676f7d;>//2
</span><span>		(imageData[i]).</span><span style=color:#98c379;>toString</span><span>(</span><span style=color:#c678dd;>16</span><span>).</span><span style=color:#98c379;>padStart</span><span>(</span><span style=color:#c678dd;>2</span><span>, </span><span style=color:#e5c07b;>'0'</span><span>),
</span><span>		(imageData[i</span><span style=color:#e06c75;>+</span><span style=color:#c678dd;>1</span><span>]).</span><span style=color:#98c379;>toString</span><span>(</span><span style=color:#c678dd;>16</span><span>).</span><span style=color:#98c379;>padStart</span><span>(</span><span style=color:#c678dd;>2</span><span>, </span><span style=color:#e5c07b;>'0'</span><span>),
</span><span>		(imageData[i</span><span style=color:#e06c75;>+</span><span style=color:#c678dd;>2</span><span>]).</span><span style=color:#98c379;>toString</span><span>(</span><span style=color:#c678dd;>16</span><span>).</span><span style=color:#98c379;>padStart</span><span>(</span><span style=color:#c678dd;>2</span><span>, </span><span style=color:#e5c07b;>'0'</span><span>),
</span><span>      </span><span style=color:#676f7d;>// 3
</span><span>	].</span><span style=color:#98c379;>join</span><span>(</span><span style=color:#e5c07b;>''</span><span>));
</span><span>}
</span></code></pre><p>So we create a new array that will hold one string of the HEX colour for every pixel in the image. We then iterate over the <code>imageData</code> array jumping 4 at a time so we get the index of the red channel for every pixel in each iteration.<p>On each of these iterations then we do a push to our <code>pixelColours</code> array with the following:<ol><li>the <code>#</code> character to denote the string we'll be creating as a HEX value<li>we take the integer from the image data and transform it to HEX with <code>toString(16)</code> we then use <code>padString(2, '0')</code> to ensure we always have 2 digits as this would cause incorrect colours if we return single characters for low channel values.<li>Finally, we just join these individual entries into a single string</ol><p>Let's try running what we have so far and try giving it a simple test image.<p><img alt="The image we'll be using for testing" src=https://zyzle.dev/blog/colour-finder-1/test.png><p>This is a pretty basic 100x100px image with some nice distinct colour blocks on a white background.<p>Let's run this in and take a look at a random section of the array<figure><img alt="image of the generated array" src=https://zyzle.dev/processed_images/65540962d26d0c5600.webp><figcaption>a section of our generated array</figcaption></figure><p>This looks good so far, we appear to be generating the array correctly, now let's look at rolling up this array into only unique colours with their associated counts.<h2 id=counting-up-and-displaying>Counting up and displaying</h2><pre class=language-js data-lang=js style=background-color:#282c34;color:#abb2bf;><code class=language-js data-lang=js><span style=color:#676f7d;>// 1
</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>colorCount </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>pixelColors</span><span>.</span><span style=color:#98c379;>reduce</span><span>((</span><span style=font-style:italic;color:#d19a66;>prev</span><span>, </span><span style=font-style:italic;color:#d19a66;>curr</span><span>) </span><span style=color:#56b6c2;>=> </span><span>{
</span><span>	prev[curr] </span><span style=color:#e06c75;>= </span><span>prev[curr] </span><span style=color:#e06c75;>? ++</span><span>prev[curr] </span><span style=color:#e06c75;>: </span><span style=color:#c678dd;>1</span><span>;
</span><span>	</span><span style=color:#e06c75;>return </span><span>prev;
</span><span>}, {});
</span><span>
</span><span style=color:#676f7d;>// 2
</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>sorted </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>Object</span><span>.</span><span style=color:#98c379;>entries</span><span>(colorCount)
</span><span>	.</span><span style=color:#98c379;>sort</span><span>((</span><span style=font-style:italic;color:#d19a66;>a</span><span>, </span><span style=font-style:italic;color:#d19a66;>b</span><span>) </span><span style=color:#56b6c2;>=> </span><span>{
</span><span>	</span><span style=color:#e06c75;>return </span><span>b[</span><span style=color:#c678dd;>1</span><span>] </span><span style=color:#e06c75;>- </span><span>a[</span><span style=color:#c678dd;>1</span><span>];
</span><span>});
</span><span>
</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>top </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>sorted</span><span>.</span><span style=color:#98c379;>slice</span><span>(</span><span style=color:#c678dd;>0</span><span>, </span><span style=color:#c678dd;>8</span><span>);
</span></code></pre><p>Ok so what we're doing here is:<ol><li>run a reducer over our array that turns it into an object whose keys are the unique colours, with a value of the number of times this pixel colour occurred.<li>take the <code>Object.entries</code> key/value pair array for this object and sort it by the value.<li>grab a slice of the first 8 elements to give us the top 8 pixel colours.</ol><p>There's no real reason behind taking 8 colours, take however many you want, it just looks good in the UI I've built :)<pre class=language-js data-lang=js style=background-color:#282c34;color:#abb2bf;><code class=language-js data-lang=js><span style=color:#56b6c2;>const </span><span style=color:#61afef;>swatches </span><span style=color:#e06c75;>= </span><span style=color:#56b6c2;>document</span><span>.</span><span style=color:#98c379;>getElementById</span><span>(</span><span style=color:#e5c07b;>'swatches'</span><span>);
</span><span style=color:#61afef;>swatches</span><span>.textContent </span><span style=color:#e06c75;>= </span><span style=color:#e5c07b;>''</span><span>;
</span><span>
</span><span style=color:#e06c75;>for </span><span>(i </span><span style=color:#e06c75;>= </span><span style=color:#c678dd;>0</span><span>; i </span><span style=color:#e06c75;>< </span><span style=color:#61afef;>top</span><span>.</span><span style=color:#56b6c2;>length</span><span>; i</span><span style=color:#e06c75;>++</span><span>){
</span><span>	</span><span style=color:#56b6c2;>let </span><span>swatch </span><span style=color:#e06c75;>= </span><span style=color:#56b6c2;>document</span><span>.</span><span style=color:#98c379;>createElement</span><span>(</span><span style=color:#e5c07b;>'span'</span><span>);
</span><span>	</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>color </span><span style=color:#e06c75;>= </span><span style=color:#56b6c2;>document</span><span>.</span><span style=color:#98c379;>createTextNode</span><span>(top[i][</span><span style=color:#c678dd;>0</span><span>]);
</span><span>	</span><span style=color:#61afef;>swatch</span><span>.</span><span style=color:#98c379;>appendChild</span><span>(color);
</span><span>	</span><span style=color:#61afef;>swatch</span><span>.</span><span style=color:#56b6c2;>style</span><span>.</span><span style=color:#56b6c2;>backgroundColor </span><span style=color:#e06c75;>= </span><span>top[i][</span><span style=color:#c678dd;>0</span><span>];
</span><span>
</span><span>	</span><span style=color:#61afef;>swatches</span><span>.</span><span style=color:#98c379;>appendChild</span><span>(swatch);
</span><span>}
</span></code></pre><p>Ok, what we're doing now is pulling out or <code>swatches</code> div we created earlier in the HTML and clearing it of any current nodes (using <code>.textContent</code> can be slightly quicker as it skips the node parsing that setting <code>innerHTML</code> would trigger).<p>For each of our colours, we create a new <code>span</code> element and create a text node with our colour in it. We append this text node to the span and then set the span's background colour to our found pixel colour. Finally, we add this to the swatches div and we're done.<p>So let's give it a try, I'll use the image above and drop it into our dropzone, let's see how this looks.<figure><img alt="the complete image analyzed on the page" src=https://zyzle.dev/processed_images/d89f1b83c53acfea00.webp><figcaption>woohoo! It works!</figcaption></figure><h2 id=so-job-done-right>So job done, right?</h2><p>Well, it's all looking good so far but let's try a more complex image...<figure><img alt="picture of a red panda sitting in a tree scanned by our analyser" src=https://zyzle.dev/processed_images/e85dcc4a16ffcc8000.webp><figcaption>Red panda from Edinburgh Zoo</figcaption></figure><p>Hmmm, that doesn't look right. We have a couple of dark greens there, but where's the brown of the trees or the red from the panda?<p>let me expand the number of swatches brought back and created:<pre class=language-js data-lang=js style=background-color:#282c34;color:#abb2bf;><code class=language-js data-lang=js><span style=color:#676f7d;>// edit the 8 in our slice call to pull back more entries
</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>top </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>sorted</span><span>.</span><span style=color:#98c379;>slice</span><span>(</span><span style=color:#c678dd;>0</span><span>, </span><span style=color:#c678dd;>8</span><span>);
</span></code></pre><figure><img alt="some more colour swatches" src=https://zyzle.dev/processed_images/80fab9d819e3ea7400.webp><figcaption>looks right?</figcaption></figure><p>So this looks ok but we've found the problem I hinted at earlier; There are so many colours in this image and we're not doing anything to group them so what we end up doing is missing out on what we as humans would consider predominant colours.<p>Let's use a simpler image to demonstrate this.<figure><img alt="square enix logo as an example" src=https://zyzle.dev/processed_images/77239e4c4fa884fd00.webp><figcaption>don't ask me why I have a Square Enix logo, I can't remember</figcaption></figure><p>If you asked someone to look at the image above and asked them, "what are the main colours here?", the answer you'd expect would be "white, black, and red" the problem we have is that there are so many tiny variations in our white and black that the reds get pushed so far down our sorted list that we won't see them.<p>So what's the solution? Well, we'll get to that in <a href=https://zyzle.dev/blog/colour-finder-2/>part 2</a> of this series, stay tuned for that :D</p><br><br><aside><h3>Thanks for reading</h3><p>If you enjoyed this article you can <a href=https://ko-fi.com/zyzle>support me on Kofi</a>. Reading this using <a href=https://brave.com/>Brave</a> will help support me as a creator while also protecting your privacy or you can tip me BAT directly from the rewards button in the address bar, thanks :)</aside><h2>Comments</h2><script data-repo-id="MDEwOlJlcG9zaXRvcnk0NzA2NjYzNw==" async crossorigin=anonymous data-emit-metadata=0 data-input-position=bottom data-lang=en data-loading=lazy data-mapping=number data-reactions-enabled=1 data-repo=Zyzle/zyzle.github.io data-term=15 data-theme=transparent_dark src=https://giscus.app/client.js></script></article><hr class=hr-footer><footer class=site-footer><nav><ul class=footer-list><li><a href=https://zyzle.dev/>Home</a><li><a href=https://zyzle.dev/blog/>Blog</a><li><a href=https://zyzle.dev/projects/>Projects</a><li><a href=https://zyzle.dev/snippets/>Snippets</a><li><a href=https://zyzle.dev/about/>About</a></ul></nav><div class=copyright><div><img alt="creative commons" height=30px src=/cc.svg width=30px><img alt=attribution height=30px src=/by.svg width=30px><img alt="share alike" height=30px src=/sa.svg width=30px></div><p>Licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>Creative Commons Attribution-ShareAlike 4.0</a></div></footer></main></div><div class=cookie-banner id=cookieBanner><h3>Cookies</h3><p>This site uses some essential cookies to make it work<p>I'd also like to use analytics cookies to gain some insites on how people are using the site<div class=cookie-controls><a href=https://zyzle.dev/cookies/>Cookie info</a><span> <button class=cookie-button-accept onclick=acceptAnalytics();>Accept Analytics Cookies</button> <button class=cookie-button-reject onclick=rejectAnalytics();>Reject Analytics Cookies</button> </span></div></div><script>function acceptAnalytics() {
                document.cookie = "analytics=true; SameSite=Lax; Secure";
                hideCookieBanner();
                startAnalytics();
            }

            function rejectAnalytics() {
                document.cookie = "analytics=false; SameSite=Lax; Secure";
                hideCookieBanner();
            }

            function hideCookieBanner() {
                const cb = document.getElementById('cookieBanner');
                cb.hidden = true;
            }

            (() => {
                const bar = document.querySelector('#progress-bar');
                const post = document.querySelector('#docmain');
                const html = document.documentElement;
                const height = post.scrollHeight;

                window.addEventListener('scroll', () => {
                    bar.style.width = (html.scrollTop / (height - html.clientHeight)) * 100 + '%';
                });
            })();

            (() => {
                for (const cookie of document.cookie.split(';')) {
                    if (cookie.trim().startsWith('analytics=')) {
                        hideCookieBanner();

                        if (cookie.split('=')[1].startsWith('true')) {
                            startAnalytics();
                        }
                    }
                }
            })();</script><script async data-dnt=false data-host=https://microanalytics.io defer id=ZwSg9rf6GA src=https://microanalytics.io/js/script.js></script>
<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,minimum-scale=1" name=viewport><meta content="Part 2 of our series on finding dominant colours in images using client-side javascript" name=description><meta content=summary name=twitter:card><meta content=@ZyzleDotDev name=twitter:site><meta content=@ZyzleDotDev name=twitter:creator><meta content=https://zyzle.dev/blog/colour-finder-2/ property=og:url><meta content="Finding Colours - Part 2: Maths is hard | Blog | Zyzle.dev" property=og:title><meta content="Part 2 of our series on finding dominant colours in images using client-side javascript" property=og:description><meta content=https://zyzle.dev/blog/colour-finder-2/panda.jpeg property=og:image><meta content=article property=og:type><title>Finding Colours - Part 2: Maths is hard | Blog | Zyzle.dev</title><link href=https://zyzle.dev/atom.xml rel=alternate title=RSS type=application/atom+xml><style>@import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&family=Nunito:ital,wght@0,400;0,700;1,400;1,700&family=Pacifico&display=swap');</style><link href=https://zyzle.dev/styles.css rel=stylesheet><link href=/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/site.webmanifest rel=manifest><script src="https://www.googletagmanager.com/gtag/js?id=G-Q90233GSB3" async></script><script>function startAnalytics() {
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
    
                gtag('config', 'G-Q90233GSB3');
            }</script><script type=application/ld+json>
{
	"@context": "https://schema.org",
	"@type": "BlogPosting",
	"Headline": "Finding Colours - Part 2: Maths is hard",
	"datePublished": "2022-07-16",
	"author": [{
		"@type": "Person",
		"name": "Colin McCulloch",
		"url": "https://zyzle.dev/about"
	}],
    "wordcount": "2214",
    "keywords": "web-dev,fun,problems,maths,",
    "license": "https://creativecommons.org/licenses/by-sa/4.0/"
}
</script><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body); src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js></script><body><header class=page-header><div class=hwrapper><h1><a class=header-link href=https://zyzle.dev/>Zyzle.dev</a></h1><span class=header-buttons> <a title="Support me on ko-fi" href=https://ko-fi.com/zyzle><img alt="support me on Ko-fi" height=40px src=/ko-fi.svg width=40px></a> <a title="Site tags" href=/tags/><img alt="site tag list" height=40px src=/tag.svg width=40px></a> <a href=https://zyzle.dev/search/ title=Search><img alt="search zyzle.dev" height=40px src=/search.svg width=40px></a> </span></div><div id=progress-bar></div></header><div class=wrapper><main class=content id=docmain><nav><a href=https://zyzle.dev/blog/>« back to blogs</a></nav><article class=post><header class=post-header><h1>Finding Colours - Part 2: Maths is hard</h1><div class=post-info><time datetime=2022-07-16>2022-07-16</time><div class=tags><a href=https://zyzle.dev/tags/web-dev/>web-dev</a><a href=https://zyzle.dev/tags/fun/>fun</a><a href=https://zyzle.dev/tags/problems/>problems</a><a href=https://zyzle.dev/tags/maths/>maths</a></div></div></header><p>Ok in <a href=https://zyzle.dev/blog/colour-finder-1/>part 1</a> we looked at finding dominant colours in an image, we got as far as showing the top 8 colours by pixel count, and showed that this isn't necessarily the best solution for real-world images as there are micro variations of colour within the image that aren't always immediately obvious to the naked eye.</p><span id=continue-reading></span><p>Let's take a closer look at the first image we had trouble with the Panda:<figure><img alt="red panda in a tree" src=https://zyzle.dev/processed_images/a395013dc69f007600.webp><figcaption>Maybe not the best pic in the world but I took it so I like it</figcaption></figure><p>The original image is cropped from a 10-megapixel DSLR and looks reasonably sharp but let's see what it looks like if we zoom in to the point where the individual pixels become visible:<figure><img alt="400% zoom of the panda image" src=https://zyzle.dev/processed_images/9a4965755b944c1b00.webp><figcaption>Now enhance... no?</figcaption></figure><p>At around 400% we can see that there's actually a fair amount of noise in this image, and what looks like single blocks of colour to our eyes are actually made up of many small colour variations that blend together into what we see.<p>So how do we go from this to pulling out what we could consider dominant colours from the image? Let's take a look at one potential way of doing things.<h2 id=k-means-clustering><em>k</em>-means clustering</h2><p>We're looking to find distinct groups of similar colours, to do this we'll use what's known as <a href=https://en.wikipedia.org/wiki/K-means_clustering>k-means clustering</a> we're going to use the naïve k-means which is one of the more simple versions of the algorithm and is unoptimized. The basic steps are as follows:<ol><li>Grab all of the colours from the image as 3-point coordinates<li>Determine an initial set of points, we'll select these at random, our <em>k</em> clusters<li><strong>Assign</strong> each colour to one of these initial <em>k</em> means based on the colours' Euclidean distance to the cluster<li><strong>Update</strong> the means centroids based on the colours assigned to it</ol><p>We repeat steps 3 and 4 until updates no longer change the <em>k</em>-means, this is known as <em>convergence</em><blockquote><p>It should be noted that the algorithm may never actually converge, so we'll probably add in an artificial limit to how many times we want to run our assign/update steps.</blockquote><h2 id=colours-in-3d-space>Colours in 3D space</h2><p>Let's revisit our <a href=https://developer.mozilla.org/en-US/docs/Web/API/ImageData><code>ImageData</code></a> from the previous post. This contains a representation of the image split as a <code>UInt8ClampedArray</code> which might look something like the following:<pre style=background-color:#282c34;color:#abb2bf;><code><span>     pixel 1         pixel 2         pixel 3         pixel 4
</span><span>|---------------|---------------|---------------|---------------|
</span><span>|255|255|255|255| 0 | 0 | 0 |255|255|255|255|255| 0 | 0 | 0 |255|
</span><span>|---------------|---------------|---------------|---------------|
</span><span>    #FFFFFFFF       #000000FF       #FFFFFFFF       #000000FF
</span></code></pre><p>So each pixel here is made up of 3 colours that can be represented as an integer between 0 and 255 (we're ignoring the alpha-channel which deals with the pixels' opacity).<p>Let's imagine these colours as a point in 3-dimensional space, where our red, green, and blue values become <code>(x, y, z)</code> coordinates, so a fully black pixel would exist at the origin <code>(0, 0, 0)</code> and a white one would be at point <code>(255, 255, 255)</code>.<p>Let's change up the code to give us an array of unique colour objects in the form <code>{ r: number, b: number, g: number }</code>, we'll remove most of the code in our file, everything after we grab the <code>imageData</code> array:<pre class=language-js data-lang=js style=background-color:#282c34;color:#abb2bf;><code class=language-js data-lang=js><span style=color:#56b6c2;>const </span><span style=color:#61afef;>imageData </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>ctx</span><span>.</span><span style=color:#98c379;>getImageData</span><span>(</span><span style=color:#c678dd;>0</span><span>, </span><span style=color:#c678dd;>0</span><span>, </span><span style=color:#61afef;>ibm</span><span>.</span><span style=color:#56b6c2;>width</span><span>, </span><span style=color:#61afef;>ibm</span><span>.</span><span style=color:#56b6c2;>height</span><span>).</span><span style=color:#56b6c2;>data</span><span>;
</span><span>
</span><span style=color:#56b6c2;>let </span><span>colorData </span><span style=color:#e06c75;>= </span><span>[];
</span><span>
</span><span style=color:#e06c75;>for </span><span>(i </span><span style=color:#e06c75;>= </span><span style=color:#c678dd;>0</span><span>; i </span><span style=color:#e06c75;>< </span><span style=color:#61afef;>imageData</span><span>.</span><span style=color:#56b6c2;>length</span><span>; i </span><span style=color:#e06c75;>+= </span><span style=color:#c678dd;>4</span><span>) {
</span><span>	</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>colStr </span><span style=color:#e06c75;>= </span><span>[
</span><span>		imageData[i],
</span><span>		imageData[i</span><span style=color:#e06c75;>+</span><span style=color:#c678dd;>1</span><span>],
</span><span>		imageData[i</span><span style=color:#e06c75;>+</span><span style=color:#c678dd;>2</span><span>]
</span><span>	].</span><span style=color:#98c379;>join</span><span>(</span><span style=color:#e5c07b;>','</span><span>);
</span><span>
</span><span>	</span><span style=color:#61afef;>colorData</span><span>.</span><span style=color:#98c379;>push</span><span>(colStr);
</span><span>}
</span><span>
</span><span style=color:#676f7d;>// 1
</span><span>colorData </span><span style=color:#e06c75;>= </span><span>[</span><span style=color:#e06c75;>...new </span><span style=color:#61afef;>Set</span><span>(colorData)];
</span><span>
</span><span>colorData </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>colorData</span><span>.</span><span style=color:#98c379;>map</span><span>(</span><span style=font-style:italic;color:#d19a66;>v </span><span style=color:#56b6c2;>=> </span><span>{
</span><span>	</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>rgb </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>v</span><span>.</span><span style=color:#98c379;>split</span><span>(</span><span style=color:#e5c07b;>','</span><span>);
</span><span>	</span><span style=color:#e06c75;>return </span><span>{
</span><span>		r: rgb[</span><span style=color:#c678dd;>0</span><span>],
</span><span>		g: rgb[</span><span style=color:#c678dd;>1</span><span>],
</span><span>		b: rgb[</span><span style=color:#c678dd;>2</span><span>],
</span><span>	};
</span><span>});
</span></code></pre><p>So we initially now create a string of the colour with each channel separated by a comma. The reason behind this is it makes it super simple (and quick) to reduce this to unique colours by simply pushing the array into a <code>Set</code> and spreading this back into an array (<code>1</code>), after that, we map these strings back into objects and we're done.<p>If we take the cropped section of our panda image above it would create a set of colours that will look as follows when graphed:<figure><img alt="showing the pixel colours plotted in a 3D coordinate space" src=3d-1.gif><figcaption>Pixel colours shown in a 3D coordinate space</figcaption></figure><blockquote><p>The generation of these graphs is a little outside the scope of this post so I'll not be going over it just the creation of the dataset because that's what we'll be using for our colour calculations. If you want to know more check out the <a href=https://github.com/Zyzle/image-colours/tree/v2.0.0>project's source</a> and the <a href=https://plotly.com/javascript/>Plotly.js</a> library</blockquote><h2 id=random-k-clusters>Random <em>k</em>-clusters</h2><p>For the next step we'll take 8 unique random colours from our array using the following:<pre class=language-js data-lang=js style=background-color:#282c34;color:#abb2bf;><code class=language-js data-lang=js><span style=color:#56b6c2;>let </span><span>kClusters </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>Array</span><span>.</span><span style=color:#98c379;>from</span><span>({ length: </span><span style=color:#c678dd;>8 </span><span>}, () </span><span style=color:#56b6c2;>=> </span><span>{
</span><span>	</span><span style=color:#e06c75;>return </span><span>colorData[
</span><span>		</span><span style=color:#56b6c2;>Math</span><span>.</span><span style=color:#98c379;>floor</span><span>(</span><span style=color:#56b6c2;>Math</span><span>.</span><span style=color:#98c379;>random</span><span>() </span><span style=color:#e06c75;>* </span><span style=color:#61afef;>colorData</span><span>.</span><span style=color:#56b6c2;>length</span><span>)
</span><span>	];
</span><span>});
</span></code></pre><p><code>Array.from</code> lets us provide a set of config options to define the length of the array we want, and a mapping function that we can use to populate the array with random items from our <code>colorData</code> array. There is a slight chance here that we could have duplicated initial clusters but this should be low enough to not be a problem on most images with a reasonably high enough number of distinct colours.<h2 id=assign-colours-to-clusters>Assign colours to clusters</h2><p>Now we have our initial clusters we're going to assign every colour to one (and just one) of these clusters. Remember we started treating colours as points in 3D space? Well, this is why for each point we will calculate what's known as the <a href=https://en.wikipedia.org/wiki/Euclidean_distance>Euclidean distance</a> to each of our <em>k</em>-clusters and assign the colour to the closest one.<p>The equation to calculate this is the following for points <code>p,q</code>.<p>$$d(p,q)={\sqrt {(p_{1}-q_{1})^{2}+(p_{2}-q_{2})^{2}+(p_{3}-q_{3})^{2}}}.$$<p>What we're doing in the above is repeatedly applying Pythagorean theorem for each of our 3 planes as shown in the image below:<figure><img alt="some alt" src=https://zyzle.dev/processed_images/95c3d03d77a098e200.webp><figcaption>Euclidean distance in 3 dimensions <a href="https://commons.wikimedia.org/w/index.php?curid=67617269">By Kmhkmh - Own work, CC BY 4.0</a></figcaption></figure><p>First we'll add a function to calculate this distance outside of our drop handler:<pre class=language-js data-lang=js style=background-color:#282c34;color:#abb2bf;><code class=language-js data-lang=js><span style=color:#56b6c2;>function </span><span style=color:#98c379;>calcEuclideanDist</span><span>(</span><span style=font-style:italic;color:#d19a66;>p</span><span>, </span><span style=font-style:italic;color:#d19a66;>q</span><span>) {
</span><span>	</span><span style=color:#e06c75;>return </span><span style=color:#56b6c2;>Math</span><span>.</span><span style=color:#98c379;>sqrt</span><span>(
</span><span>		</span><span style=color:#56b6c2;>Math</span><span>.</span><span style=color:#98c379;>pow</span><span>(</span><span style=color:#61afef;>p</span><span>.r </span><span style=color:#e06c75;>- </span><span style=color:#61afef;>q</span><span>.r, </span><span style=color:#c678dd;>2</span><span>) </span><span style=color:#e06c75;>+
</span><span>		</span><span style=color:#56b6c2;>Math</span><span>.</span><span style=color:#98c379;>pow</span><span>(</span><span style=color:#61afef;>p</span><span>.g </span><span style=color:#e06c75;>- </span><span style=color:#61afef;>q</span><span>.g, </span><span style=color:#c678dd;>2</span><span>) </span><span style=color:#e06c75;>+
</span><span>		</span><span style=color:#56b6c2;>Math</span><span>.</span><span style=color:#98c379;>pow</span><span>(</span><span style=color:#61afef;>p</span><span>.b </span><span style=color:#e06c75;>- </span><span style=color:#61afef;>q</span><span>.b, </span><span style=color:#c678dd;>2</span><span>)
</span><span>	);
</span><span>}
</span></code></pre><p>Built in <code>Math</code> functions can be used here so no big calculations needed from us.<p>Now we need to assign all of our unique colours to one of the selected <em>k</em>-clusters. For the first attempt at this we'll run a reducer over the <code>colorData</code> array we created earlier:<pre class=language-js data-lang=js style=background-color:#282c34;color:#abb2bf;><code class=language-js data-lang=js><span style=color:#676f7d;>// 1
</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>clusteredData </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>colorData</span><span>.</span><span style=color:#98c379;>reduce</span><span>(
</span><span>	(</span><span style=font-style:italic;color:#d19a66;>prev</span><span>, </span><span style=font-style:italic;color:#d19a66;>curr</span><span>) </span><span style=color:#56b6c2;>=> </span><span>{
</span><span>		</span><span style=color:#676f7d;>// 2
</span><span>		</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>distances </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>kClusters</span><span>.</span><span style=color:#98c379;>map</span><span>((</span><span style=font-style:italic;color:#d19a66;>k</span><span>) </span><span style=color:#56b6c2;>=> </span><span style=color:#98c379;>calcEuclideanDist</span><span>(k, curr));
</span><span>		</span><span style=color:#676f7d;>// 3
</span><span>		</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>minDistance </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>distances</span><span>.</span><span style=color:#98c379;>reduce</span><span>(
</span><span>			(</span><span style=font-style:italic;color:#d19a66;>a</span><span>, </span><span style=font-style:italic;color:#d19a66;>b</span><span>) </span><span style=color:#56b6c2;>=> Math</span><span>.</span><span style=color:#98c379;>min</span><span>(a, b),
</span><span>			</span><span style=color:#56b6c2;>Infinity
</span><span>		);
</span><span>		</span><span style=color:#676f7d;>// 4
</span><span>		</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>selectedK </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>distances</span><span>.</span><span style=color:#98c379;>findIndex</span><span>((</span><span style=font-style:italic;color:#d19a66;>e</span><span>) </span><span style=color:#56b6c2;>=> </span><span>e </span><span style=color:#e06c75;>=== </span><span>minDistance);
</span><span>
</span><span>		</span><span style=color:#676f7d;>// 5
</span><span>		prev[selectedK] </span><span style=color:#e06c75;>= </span><span>[</span><span style=color:#e06c75;>...</span><span>prev[selectedK], curr];
</span><span>
</span><span>		</span><span style=color:#e06c75;>return </span><span>prev;
</span><span>	},
</span><span>	</span><span style=color:#61afef;>Array</span><span>.</span><span style=color:#98c379;>from</span><span>({ length: </span><span style=color:#c678dd;>8 </span><span>}, () </span><span style=color:#56b6c2;>=> </span><span>[])
</span><span>);
</span></code></pre><p>I say the first attempt because this reducer is pretty inefficient, for our zoomed image with ~125k unique colours it took around 25s to complete and since we'll be running this in multiple passes per image that time will add up significantly. We'll leave optimisation for now though and go through this line by line:<ol><li>we create our reducer function for our <code>colorData</code> array and create a 2D array as our initial value.<li>we map the <code>kClusters</code> array and call our <code>calcEuclideanDist</code> function passing the current cluster and colour<li>another reducer then to find the smallest distance from our newly created <code>distances</code> array. We could just spread the array into <code>Math.min</code> here but that will fail if we ever decide to increase the number of <em>k</em>-clusters beyond a certain point<li>now we know the smallest distance we get its index from <code>distances</code><li>and now add this colour to the array at that index in the array we are creating in this reducer. Phew</ol><p>What we've created here in our <code>clusteredData</code> is an 8-item array with all our image colours sorted into the same index as our initially created clusters. If we console log it out it'll look something like this:<pre style=background-color:#282c34;color:#abb2bf;><code><span>(8) [Array(24865), Array(32390), Array(7014), Array(3894), 
</span><span>Array(3236), Array(19094), Array(18360), Array(16286)]
</span></code></pre><h2 id=update-our-k-clusters>Update our <em>k</em>-clusters</h2><p>Now we have all of our colour points assigned to one of the clusters we'll use these collections to recalculate what our <em>k</em>-clusters should be. The formula to do this is as follows:<p>$$m_{i}^{(t+1)}={\frac {1}{\left|S_{i}^{(t)}\right|}}\sum_{x_{j}\in S_{i}^{(t)}}x_{j}$$<p>This looks complicated but it's really just telling us that for each of the coordinate components <code>(x,y,z)</code>, or in our case <code>(r,g,b)</code>, for all of the colours in our cluster array we take the average of that component and use it... I think.<p>We can calculate these new clusters by mapping over our clustered data and averaging the individual channel components:<pre class=language-js data-lang=js style=background-color:#282c34;color:#abb2bf;><code class=language-js data-lang=js><span style=color:#56b6c2;>const </span><span style=color:#61afef;>newKs </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>clusteredData</span><span>.</span><span style=color:#98c379;>map</span><span>((</span><span style=font-style:italic;color:#d19a66;>colors</span><span>) </span><span style=color:#56b6c2;>=> </span><span>{
</span><span>	</span><span style=color:#56b6c2;>let </span><span>r </span><span style=color:#e06c75;>= </span><span style=color:#c678dd;>0</span><span>;
</span><span>	</span><span style=color:#56b6c2;>let </span><span>g </span><span style=color:#e06c75;>= </span><span style=color:#c678dd;>0</span><span>;
</span><span>	</span><span style=color:#56b6c2;>let </span><span>b </span><span style=color:#e06c75;>= </span><span style=color:#c678dd;>0</span><span>;
</span><span>
</span><span>	</span><span style=color:#61afef;>colors</span><span>.</span><span style=color:#98c379;>forEach</span><span>((</span><span style=font-style:italic;color:#d19a66;>color</span><span>) </span><span style=color:#56b6c2;>=> </span><span>{
</span><span>		r </span><span style=color:#e06c75;>+= </span><span style=color:#61afef;>color</span><span>.r;
</span><span>		g </span><span style=color:#e06c75;>+= </span><span style=color:#61afef;>color</span><span>.g;
</span><span>		b </span><span style=color:#e06c75;>+= </span><span style=color:#61afef;>color</span><span>.b;
</span><span>	});
</span><span>
</span><span>	</span><span style=color:#e06c75;>return </span><span>{
</span><span>		r: </span><span style=color:#56b6c2;>Math</span><span>.</span><span style=color:#98c379;>round</span><span>(r </span><span style=color:#e06c75;>/ </span><span style=color:#61afef;>colors</span><span>.</span><span style=color:#56b6c2;>length</span><span>),
</span><span>		g: </span><span style=color:#56b6c2;>Math</span><span>.</span><span style=color:#98c379;>round</span><span>(g </span><span style=color:#e06c75;>/ </span><span style=color:#61afef;>colors</span><span>.</span><span style=color:#56b6c2;>length</span><span>),
</span><span>		b: </span><span style=color:#56b6c2;>Math</span><span>.</span><span style=color:#98c379;>round</span><span>(b </span><span style=color:#e06c75;>/ </span><span style=color:#61afef;>colors</span><span>.</span><span style=color:#56b6c2;>length</span><span>),
</span><span>	};
</span><span>});
</span></code></pre><h2 id=iterating-to-find-clusters>Iterating to find clusters</h2><p>Ok, we're not quite done yet. We need a way to iterate over this process and a way of determining whether or not we're 'done'.<p>As mentioned before given the nature of the algorithm and the fact that we're rounding values in certain places there is a chance that it will never fully converge, that is, our <em>k</em>-clusters will never stop updating their positions on subsequent iterations.<p>I'm going to take 2 approaches to solve this issue, the first will simply be a hard limit on the number of iterations allowed, say 10, and the second will be to calculate a distance shifted between our old and new clusters and stop if this shift falls below a certain threshold.<p>First off let's move our two cluster calculation steps from above out into their own function<pre class=language-js data-lang=js style=background-color:#282c34;color:#abb2bf;><code class=language-js data-lang=js><span style=color:#56b6c2;>function </span><span style=color:#98c379;>calcNewClusters</span><span>(</span><span style=font-style:italic;color:#d19a66;>kClusters</span><span>, </span><span style=font-style:italic;color:#d19a66;>colorData</span><span>) {
</span><span>	</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>clusteredData </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>colorData</span><span>.</span><span style=color:#98c379;>reduce</span><span>(
</span><span>		</span><span style=color:#676f7d;>// ...
</span><span>	);
</span><span>
</span><span>	</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>newKs </span><span style=color:#e06c75;>= </span><span style=color:#61afef;>clusteredData</span><span>.</span><span style=color:#98c379;>map</span><span>((</span><span style=font-style:italic;color:#d19a66;>colors</span><span>) </span><span style=color:#56b6c2;>=> </span><span>{
</span><span>		</span><span style=color:#676f7d;>// ...
</span><span>	});
</span><span>
</span><span>	</span><span style=color:#e06c75;>return </span><span>newKs;
</span><span>}
</span></code></pre><p>Where this code used to be, after our initialisation of our initial <em>k</em>-clusters, we'll create 3 new variables<pre class=language-js data-lang=js style=background-color:#282c34;color:#abb2bf;><code class=language-js data-lang=js><span style=color:#56b6c2;>let </span><span>iterations </span><span style=color:#e06c75;>= </span><span style=color:#c678dd;>0</span><span>;
</span><span style=color:#56b6c2;>let </span><span>distanceShift </span><span style=color:#e06c75;>= </span><span style=color:#c678dd;>0</span><span>;
</span><span style=color:#56b6c2;>let </span><span>newClusters </span><span style=color:#e06c75;>= </span><span>[];
</span></code></pre><p><code>iterations</code> will hold how many times we've run through our steps, we'll use this to enforce our hard limit, <code>distanceShift</code> will be used to hold the change between the newly calculated set of <em>k</em>-clusters <code>newClusters</code> and the previous one.<p>I'm going to use a <code>do</code>/<code>while</code> loop here to call our <code>calcNewClusters</code> function, calculate our <code>distanceShift</code>, and replace our current set of <em>k</em>-clusters with the newly generated one.<pre class=language-js data-lang=js style=background-color:#282c34;color:#abb2bf;><code class=language-js data-lang=js><span style=color:#e06c75;>do </span><span>{
</span><span>	newClusters </span><span style=color:#e06c75;>= </span><span style=color:#98c379;>calcNewClusters</span><span>(kClusters, colorData);
</span><span>
</span><span>	</span><span style=color:#61afef;>newClusters</span><span>.</span><span style=color:#98c379;>forEach</span><span>((</span><span style=font-style:italic;color:#d19a66;>v</span><span>, </span><span style=font-style:italic;color:#d19a66;>i</span><span>) </span><span style=color:#56b6c2;>=> </span><span>{
</span><span>		distanceShift </span><span style=color:#e06c75;>+= </span><span style=color:#98c379;>calcEuclideanDist</span><span>(v, kClusters[i]);
</span><span>	});
</span><span>
</span><span>	distanceShift </span><span style=color:#e06c75;>= </span><span>distanceShift </span><span style=color:#e06c75;>/ </span><span style=color:#61afef;>newClusters</span><span>.</span><span style=color:#56b6c2;>length</span><span>;
</span><span>
</span><span>	kClusters </span><span style=color:#e06c75;>= </span><span>newClusters;
</span><span>	iterations </span><span style=color:#e06c75;>+= </span><span style=color:#c678dd;>1</span><span>;
</span><span>} </span><span style=color:#e06c75;>while </span><span>(distanceShift </span><span style=color:#e06c75;>>= </span><span style=color:#c678dd;>5 </span><span style=color:#e06c75;>&& </span><span>iterations </span><span style=color:#e06c75;>< </span><span style=color:#c678dd;>10</span><span>);
</span></code></pre><p>For <code>distanceShift</code> once we've found our new clusters, we take each of those and calculate the Euclidean distance between it and its previous position and average these distances. I've arbitrarily chosen 5 to be the minimum required shift before we consider our iterations done but you can try other values here if you like.<h2 id=update-swatches>Update swatches</h2><p>The final step then is to update our swatches to use our found <em>k</em>-clusters:<pre class=language-js data-lang=js style=background-color:#282c34;color:#abb2bf;><code class=language-js data-lang=js><span style=color:#e06c75;>for </span><span>(i </span><span style=color:#e06c75;>= </span><span style=color:#c678dd;>0</span><span>; i </span><span style=color:#e06c75;>< </span><span style=color:#61afef;>kClusters</span><span>.</span><span style=color:#56b6c2;>length</span><span>; i</span><span style=color:#e06c75;>++</span><span>) {
</span><span>	</span><span style=color:#56b6c2;>let </span><span>swatch </span><span style=color:#e06c75;>= </span><span style=color:#56b6c2;>document</span><span>.</span><span style=color:#98c379;>createElement</span><span>(</span><span style=color:#e5c07b;>"span"</span><span>);
</span><span>	</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>colorStr </span><span style=color:#e06c75;>= </span><span style=color:#e5c07b;>`#</span><span style=color:#c678dd;>${</span><span>kClusters[i].r
</span><span style=color:#e5c07b;>		</span><span>.</span><span style=color:#98c379;>toString</span><span>(</span><span style=color:#c678dd;>16</span><span>)
</span><span style=color:#e5c07b;>		</span><span>.</span><span style=color:#98c379;>padStart</span><span>(</span><span style=color:#c678dd;>2</span><span>, </span><span style=color:#e5c07b;>"0"</span><span>)</span><span style=color:#c678dd;>}${</span><span>kClusters[i].g
</span><span style=color:#e5c07b;>		</span><span>.</span><span style=color:#98c379;>toString</span><span>(</span><span style=color:#c678dd;>16</span><span>)
</span><span style=color:#e5c07b;>		</span><span>.</span><span style=color:#98c379;>padStart</span><span>(</span><span style=color:#c678dd;>2</span><span>, </span><span style=color:#e5c07b;>"0"</span><span>)</span><span style=color:#c678dd;>}${</span><span>kClusters[i].b
</span><span style=color:#e5c07b;>		</span><span>.</span><span style=color:#98c379;>toString</span><span>(</span><span style=color:#c678dd;>16</span><span>)
</span><span style=color:#e5c07b;>		</span><span>.</span><span style=color:#98c379;>padStart</span><span>(</span><span style=color:#c678dd;>2</span><span>, </span><span style=color:#e5c07b;>"0"</span><span>)</span><span style=color:#c678dd;>}</span><span style=color:#e5c07b;>`</span><span>;
</span><span>
</span><span>	</span><span style=color:#56b6c2;>const </span><span style=color:#61afef;>color </span><span style=color:#e06c75;>= </span><span style=color:#56b6c2;>document</span><span>.</span><span style=color:#98c379;>createTextNode</span><span>(colorStr);
</span><span>	</span><span style=color:#61afef;>swatch</span><span>.</span><span style=color:#98c379;>appendChild</span><span>(color);
</span><span>	</span><span style=color:#61afef;>swatch</span><span>.</span><span style=color:#61afef;>classList</span><span>.</span><span style=color:#98c379;>add</span><span>(</span><span style=color:#e5c07b;>"p-2"</span><span>);
</span><span>	</span><span style=color:#61afef;>swatch</span><span>.</span><span style=color:#61afef;>classList</span><span>.</span><span style=color:#98c379;>add</span><span>(</span><span style=color:#e5c07b;>"mb-2"</span><span>);
</span><span>	</span><span style=color:#61afef;>swatch</span><span>.</span><span style=color:#56b6c2;>style</span><span>.</span><span style=color:#56b6c2;>backgroundColor </span><span style=color:#e06c75;>= </span><span>colorStr;
</span><span>
</span><span>	</span><span style=color:#61afef;>swatches</span><span>.</span><span style=color:#98c379;>appendChild</span><span>(swatch);
</span><span>}
</span></code></pre><p>The only difference here is we're generating a hex string from our colour objects.<figure><img alt="screenshot of the app in action" src=https://zyzle.dev/processed_images/f958d72b5c585d8c00.webp><figcaption>Random screenshot from my favourite game, bonus points for first commenter who can identify it</figcaption></figure><p>And this looks a lot better, there will always be some level of randomness in what the eventual clusters chosen might be because of the calculations, but this is a lot better than what we had before.<h2 id=so-this-time-we-re-done-right>So <em>this</em> time we're done, right?</h2><p>Well, no. As mentioned earlier this code has some serious efficiency problems, the image above was about 1000x400 pixels and this calculation took 5 iterations (the distanceShift went down to 3.5), but this took over 80 seconds!<figure><img alt="app used with a digital camera photograph of my dog" src=https://zyzle.dev/processed_images/c7b426b991eeb95500.webp><figcaption>The algorithm can have other drawbacks too</figcaption></figure><p>This shows some of the other drawbacks, the colours here look good but I would expect to see some deeper oranges, the brighter yellow, or even something closer to black. This is likely due to the random nature of the initial choice of clusters. Also, it took over 5 minutes for 6 iterations on this 4000x3000 pixel image.<p>We'll look at addressing these issues in Part 3 of this series. For now though, the completed code for this part can be found in our <a href=https://github.com/Zyzle/image-colours/tree/v2.0.0>Github repository</a></p><br><br><aside><h3>Thanks for reading</h3><p>If you enjoyed this article you can <a href=https://ko-fi.com/zyzle>support me on Kofi</a>. Reading this using <a href=https://brave.com/>Brave</a> will help support me as a creator while also protecting your privacy or you can tip me BAT directly from the rewards button in the address bar, thanks :)</aside><h2>Comments</h2><script data-repo-id="MDEwOlJlcG9zaXRvcnk0NzA2NjYzNw==" async crossorigin=anonymous data-emit-metadata=0 data-input-position=bottom data-lang=en data-loading=lazy data-mapping=number data-reactions-enabled=1 data-repo=Zyzle/zyzle.github.io data-term=16 data-theme=transparent_dark src=https://giscus.app/client.js></script></article><hr class=hr-footer><footer class=site-footer><nav><ul class=footer-list><li><a href=https://zyzle.dev/>Home</a><li><a href=https://zyzle.dev/blog/>Blog</a><li><a href=https://zyzle.dev/projects/>Projects</a><li><a href=https://zyzle.dev/snippets/>Snippets</a><li><a href=https://zyzle.dev/about/>About</a></ul></nav><div class=copyright><div><img alt="creative commons" height=30px src=/cc.svg width=30px><img alt=attribution height=30px src=/by.svg width=30px><img alt="share alike" height=30px src=/sa.svg width=30px></div><p>Licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>Creative Commons Attribution-ShareAlike 4.0</a></div></footer></main></div><div class=cookie-banner id=cookieBanner><h3>Cookies</h3><p>This site uses some essential cookies to make it work<p>I'd also like to use analytics cookies to gain some insites on how people are using the site<div class=cookie-controls><a href=https://zyzle.dev/cookies/>Cookie info</a><span> <button class=cookie-button-accept onclick=acceptAnalytics();>Accept Analytics Cookies</button> <button class=cookie-button-reject onclick=rejectAnalytics();>Reject Analytics Cookies</button> </span></div></div><script>function acceptAnalytics() {
                document.cookie = "analytics=true; SameSite=Lax; Secure";
                hideCookieBanner();
                startAnalytics();
            }

            function rejectAnalytics() {
                document.cookie = "analytics=false; SameSite=Lax; Secure";
                hideCookieBanner();
            }

            function hideCookieBanner() {
                const cb = document.getElementById('cookieBanner');
                cb.hidden = true;
            }

            (() => {
                const bar = document.querySelector('#progress-bar');
                const post = document.querySelector('#docmain');
                const html = document.documentElement;
                const height = post.scrollHeight;

                window.addEventListener('scroll', () => {
                    bar.style.width = (html.scrollTop / (height - html.clientHeight)) * 100 + '%';
                });
            })();

            (() => {
                for (const cookie of document.cookie.split(';')) {
                    if (cookie.trim().startsWith('analytics=')) {
                        hideCookieBanner();

                        if (cookie.split('=')[1].startsWith('true')) {
                            startAnalytics();
                        }
                    }
                }
            })();</script><script async data-dnt=false data-host=https://microanalytics.io defer id=ZwSg9rf6GA src=https://microanalytics.io/js/script.js></script>